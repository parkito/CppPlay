#include "iostream"
//https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners
class Holder {
public:
  Holder(int size)  // Constructor
  {
    m_data = new int[size];
    m_size = size;
  }

  ~Holder()  // Destructor
  {
    delete[] m_data;
  }
  // generated by compiler
  Holder(const Holder& other) {
    m_data = new int[other.m_size];                                // (1)
    std::copy(other.m_data, other.m_data + other.m_size, m_data);  // (2)
    m_size = other.m_size;
  }

  //move constructor
  Holder(Holder&& other)     // <-- rvalue reference in input
  {
    m_data = other.m_data;   // (1)
    m_size = other.m_size;
    other.m_data = nullptr;  // (2)
    other.m_size = 0;
  }

  //copy operator generated by compiler
  Holder& operator=(const Holder& other)
  {
    if(this == &other) return *this;  // (1)
    delete[] m_data;  // (2)
    m_data = new int[other.m_size];
    std::copy(other.m_data, other.m_data + other.m_size, m_data);
    m_size = other.m_size;
    return *this;  // (3)
  }

  //move operator
  Holder& operator=(Holder&& other)     // <-- rvalue reference in input
  {
    if (this == &other) return *this;

    delete[] m_data;         // (1)

    m_data = other.m_data;   // (2)
    m_size = other.m_size;

    other.m_data = nullptr;  // (3)
    other.m_size = 0;

    return *this;
  }

private:
  int* m_data;
  size_t m_size;
};

Holder createHolder(int size)
{
  return Holder(size);
}

int main() {
  //  C++0x has introduced a new type called rvalue reference, denoted by placing a double ampersand
  //  && after some type. Such rvalue reference lets you modify the value of a temporary object:
  //  it's like removing the const attribute in the second line above!
  std::string s1 = "Hello ";
  std::string s2 = "world";
  std::string&& s_rref = s1 + s2;  // the result of s1 + s2 is an rvalue
  s_rref += ", my friend";         // I can change the temporary string!
  std::cout << s_rref << '\n';     // prints "Hello world, my friend"

  Holder h1(10000);  // regular constructor
  Holder h2 = h1;    // copy constructor
  Holder h3(h1);     // copy constructor (alternate syntax)

  Holder h = createHolder(1000); //2 operation 1) allocation and copy operator

  Holder h4(1000);           // h1 is an lvalue
  Holder h5(std::move(h4));  // move-constructor invoked (because of rvalue in input)
}